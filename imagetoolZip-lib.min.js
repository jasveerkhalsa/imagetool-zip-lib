/**
 * ImageTool.org - Standalone Image Processing & Zip Library
 * Fast, dependency-free JavaScript library for image processing and file compression
 * Author: ImageTool.org Team
 * Version: 1.0.4 (Fixed ZIP offset issue)
 */

class ImageToolLib{constructor(){this.version="1.0.1",this.files=new Map,this.crcTable=null}loadImage(t){return new Promise(((e,s)=>{const a=new Image;a.onload=()=>e(a),a.onerror=s,a.src=URL.createObjectURL(t)}))}async processImage(t,e={}){const s=await this.loadImage(t),a=document.createElement("canvas"),i=a.getContext("2d");return a.width=e.width||s.width,a.height=e.height||s.height,e.rotate&&(i.translate(a.width/2,a.height/2),i.rotate(e.rotate*Math.PI/180),i.translate(-a.width/2,-a.height/2)),i.drawImage(s,0,0,a.width,a.height),void 0!==e.brightness&&this.adjustBrightness(i,a,e.brightness),void 0!==e.contrast&&this.adjustContrast(i,a,e.contrast),e.blur&&this.applyBlur(i,a,e.blur),new Promise((t=>{a.toBlob(t,e.format||"image/jpeg",e.quality||.9)}))}adjustBrightness(t,e,s){const a=t.getImageData(0,0,e.width,e.height),i=a.data;for(let t=0;t<i.length;t+=4)i[t]+=s,i[t+1]+=s,i[t+2]+=s;t.putImageData(a,0,0)}adjustContrast(t,e,s){const a=t.getImageData(0,0,e.width,e.height),i=a.data,n=259*(s+255)/(255*(259-s));for(let t=0;t<i.length;t+=4)i[t]=n*(i[t]-128)+128,i[t+1]=n*(i[t+1]-128)+128,i[t+2]=n*(i[t+2]-128)+128;t.putImageData(a,0,0)}applyBlur(t,e,s){t.filter=`blur(${s}px)`;const a=t.getImageData(0,0,e.width,e.height);t.putImageData(a,0,0),t.filter="none"}async resizeImage(t,e,s,a=!0){const i={width:e,height:s};if(a){const a=await this.loadImage(t),n=a.width/a.height;e/s>n?i.width=s*n:i.height=e/n}return this.processImage(t,i)}addFile(t,e){this.files.set(t,e)}removeFile(t){this.files.delete(t)}clearFiles(){this.files.clear()}getFileList(){return Array.from(this.files.keys())}async createZip(t="images.zip"){const e=await this.generateZipBuffer(),s=new Blob([e],{type:"application/zip"});this.downloadBlob(s,t)}async generateZipBuffer(){const t=Array.from(this.files.entries()),e=[];for(const[s,a]of t){const t=new Uint8Array(await a.arrayBuffer()),i=this.calculateCRC32(t);e.push({name:s,data:t,size:t.length,compressedSize:t.length,crc32:i,offset:0})}let s=0;e.forEach((t=>{t.offset=s,s+=30+t.name.length+t.size}));const a=s,i=e.reduce(((t,e)=>t+46+e.name.length),0),n=new ArrayBuffer(a+i+22),r=new DataView(n),o=new Uint8Array(n);s=0,e.forEach((t=>{r.setUint32(s,67324752,!0),s+=4,r.setUint16(s,20,!0),s+=2,r.setUint16(s,0,!0),s+=2,r.setUint16(s,0,!0),s+=2,r.setUint16(s,0,!0),s+=2,r.setUint16(s,0,!0),s+=2,r.setUint32(s,t.crc32,!0),s+=4,r.setUint32(s,t.compressedSize,!0),s+=4,r.setUint32(s,t.size,!0),s+=4,r.setUint16(s,t.name.length,!0),s+=2,r.setUint16(s,0,!0),s+=2;for(let e=0;e<t.name.length;e++)o[s++]=t.name.charCodeAt(e);o.set(t.data,s),s+=t.data.length}));let h=a;return e.forEach((t=>{r.setUint32(h,33639248,!0),h+=4,r.setUint16(h,20,!0),h+=2,r.setUint16(h,20,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint32(h,t.crc32,!0),h+=4,r.setUint32(h,t.compressedSize,!0),h+=4,r.setUint32(h,t.size,!0),h+=4,r.setUint16(h,t.name.length,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint32(h,0,!0),h+=4,r.setUint32(h,t.offset,!0),h+=4;for(let e=0;e<t.name.length;e++)o[h++]=t.name.charCodeAt(e)})),r.setUint32(h,101010256,!0),h+=4,r.setUint16(h,0,!0),h+=2,r.setUint16(h,0,!0),h+=2,r.setUint16(h,e.length,!0),h+=2,r.setUint16(h,e.length,!0),h+=2,r.setUint32(h,i,!0),h+=4,r.setUint32(h,a,!0),h+=4,r.setUint16(h,0,!0),n}calculateCRC32(t){const e=this.makeCRCTable();let s=-1;for(let a=0;a<t.length;a++)s=s>>>8^e[255&(s^t[a])];return(-1^s)>>>0}makeCRCTable(){if(this.crcTable)return this.crcTable;const t=[];for(let e=0;e<256;e++){let s=e;for(let t=0;t<8;t++)s=1&s?3988292384^s>>>1:s>>>1;t[e]=s}return this.crcTable=t,t}downloadBlob(t,e){const s=URL.createObjectURL(t),a=document.createElement("a");a.href=s,a.download=e,document.body.appendChild(a),a.click(),document.body.removeChild(a),URL.revokeObjectURL(s)}async batchProcess(t,e={}){const s=[];for(const a of t)try{s.push({original:a.name,processed:await this.processImage(a,e),success:!0})}catch(t){s.push({original:a.name,error:t.message,success:!1})}return s}async convertFormat(t,e,s=.9){return this.processImage(t,{format:e,quality:s})}async compressImage(t,e=.7){return this.processImage(t,{quality:e})}async getImageDimensions(t){const e=await this.loadImage(t);return{width:e.width,height:e.height}}}